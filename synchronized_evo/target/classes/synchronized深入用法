    synchronized的两个用法：
1，对象锁：包括方法锁（默认锁对象为this当前实例对象）和同步代码块锁（自己指定锁对象）。
方法锁形式：synchronized修饰普通方法，锁对象默认为this。
代码块形式：手动指定锁对象。
2，类锁：指synchronized修饰静态的方法或指定锁为Class对象。
形式1：synchronized加在static方法上。
形式2：synchronized（*.class）{ 代码块 }
    多线程访问同步方法的7种情况：
1，两个线程同时访问一个对象的同步方法。
2，两个线程访问的是两个对象的同步方法。
3，两个线程访问的是synchronized的静态方法。
4，同时访问同步方法与非同步方法。（解决方法在com.yuan.test2包中）
5，访问同一个对象的不同的普通同步方法。（解决方法在com.yuan.test2包中）
6，同时访问静态synchronized和非静态synchronized的方法。（解决方法在com.yuan.test2包中）
7，方法抛出异常后，会释放锁。（解决方法在com.yuan.test2包中）
    由以上的7种情况可以总结出3个核心思想：
1，一把锁同时只能被一个线程获取，没有拿到锁的线程必须等待（对应1，5两种情况）。
2，每个实例都对应由自己的一把锁，实例不同锁也不同，所以并不会相互影响。
但是当锁对象是*.class以及synchronized修饰的是static方法时，那么这时所有的实例都共用的是同一把类锁（对应2，3，4，6情况）。
3，无论是方法正常执行完毕或是抛出异常，都会释放锁（第7种情况）
    synchronized的特性：
1，可重入：同一线程的外层函数获得锁之后，内层函数可以直接再次获取该锁。
   好处：避免死锁，提升封装性。
   可重入粒度测试：在com.yuan.test3包中。
2，不可中断：一旦这个锁已经被别人获得，如果我还想获得，我只能选择等待或者阻塞，直到别的线程释放这把锁。
   别人如果不释放，那我只能永远等下去。
   与synchronized不同的Lock类却拥有可中断的能力。
   缺点：（Lock类的对比在com.yuan.test4中）
1，效率低：锁的释放情况少，试图获得锁时不能设定超时，不能中断一个正在试图获得锁的线程。
2，不够灵活（读写锁更灵活）：加锁和释放的时机单一，每个锁仅有单一的条件（就是某个对象），可能是不够的
3，无法知道是否成功获取到锁。
    使用注意点：（在com.yuan.test5中演示）
1，锁对象不能为空，作用域不宜过大，避免死锁。