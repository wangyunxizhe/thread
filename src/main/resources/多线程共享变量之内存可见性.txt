    在多线程环境中，当多个线程需要共享某个变量时，synchronized和volatile都可以实现对一个变量的共享，
在java中共享数据的访问权限都必须定义为private。
    每个线程都有属于自己的内存空间，而这些内存空间都存放在主内存中，每个线程是无法直接访问主内存的。
当线程1需要修改共享变量时，首先线程1必须先修改自己内存空间中的该变量副本，之后将该变量副本更新到主内存的该变量中，
之后主内存再将更新后的变量值，同步给线程2，线程3。。。从而实现一个变量的共享。
    要实现共享变量的可见性，需要实现以下两点：
1，线程修改后的共享变量值能够及时从工作内存中刷新到主内存中。
2，其他线程能够及时把共享变量的最新值从主内存更新到自己的份工作内存中。
    会导致共享变量在线程间不可见的原因有：
1，线程会交叉执行。
2，多线程会导致代码重排序执行。
3，共享变量更新后的值没有在工作内存与主内存间及时更新。
    synchronized如何实现可见性：
1，进入语句块时，获得锁对象（就是语句块括号中的变量）
2，清空自己的工作内存
3，从主内存中拷贝变量的最新副本到自己的工作内存中
4，执行语句块中的代码
5，将更改后的共享变量的值刷新到主内存中
6，释放锁对象
    volatile如何实现可见性：
被volatile修饰的变量在每次被线程访问时，都会强迫线程从主内存中重读该变量的值，而当该变量发生变化时，
又会强迫线程将最新的值刷新到主内存中。这样一来，任何时刻不同的线程都总能看到该变量的最新值。
    但是volatile有时并不能保证变量的原子性（可参考two工程中，VolatileTest类的测试代码）
    如何在多线程中安全的使用volatile修饰变量，必须同时满足：
1，对变量的写入操作不依赖其当前的值（如num++/num--/num=num*5）
2，该变量没有包含在具有其他变量的不变式中
    synchronized与volatile的比较：
1，volatile不需要加锁，比synchronized更轻量，不会组赛线程。
2，从内存可见性角度讲，对volatile变量的读相当于加锁，对volatile变量的写相当于解锁。
3，synchronized既能保证对象的可见性，又能保证原子性。volatile只能保证对象的可见性，无法保证原子性。